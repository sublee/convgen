package assign

import (
	"go/ast"
	"go/token"

	"golang.org/x/tools/go/packages"

	"github.com/sublee/convgen/internal/codefmt"
	"github.com/sublee/convgen/internal/typeinfo"
)

// Conv represents a converter generated by Convgen regardless of explicit or
// implicit.
type Conv interface {
	// WriteDefineCode writes a function definition code for the converter.
	WriteDefineCode(*codefmt.Writer)

	// Pos returns the token position of the converter in the source code. It
	// would be token.NoPos if the converter is generated implicitly.
	Pos() token.Pos
}

// conv implements [Conv] by wrapping a function and an assigner that performs
// the actual assignment.
type conv[T assigner] struct {
	// Func declares the function signature of this converter.
	typeinfo.Func

	// assigner performs the actual assignment.
	assigner T

	// pkg is the package where this converter will be injected.
	pkg *packages.Package

	// pos is the position of the injector that defines this converter.
	pos token.Pos

	// doc is the doc comment of the injector that defines this converter.
	doc *ast.CommentGroup

	// comment is the inline comment of the injector that defines this
	// converter.
	comment *ast.CommentGroup
}

// WriteDefineCode writes a function definition code for the converter.
func (c conv[T]) WriteDefineCode(w *codefmt.Writer) {
	varX := w.Name("in")
	varY := w.Name("out")

	varErr := ""
	if c.Func.HasErr() {
		// NOTE: In writeAssignCode implementations, check varErr to determine
		// if the outermost converter function may return an error.
		varErr = w.Name("err")
	}

	if c.doc != nil {
		for _, comment := range c.doc.List {
			w.Printf("%s\n", comment.Text)
		}
	}
	w.Printf("func %s(%s %t", c.Name(), varX, c.X())

	if c.HasOut() {
		if c.HasErr() {
			w.Printf(", %s %t) (%s error)", varY, c.Y().Ref(), varErr)
		} else {
			w.Printf(", %s %t)", varY, c.Y().Ref())
		}
	} else {
		if c.HasErr() {
			w.Printf(") (%s %t, %s error)", varY, c.Y(), varErr)
		} else {
			w.Printf(") (%s %t)", varY, c.Y())
		}
	}
	w.Printf("{")

	if c.comment != nil && len(c.comment.List) != 0 {
		for _, comment := range c.comment.List {
			w.Printf("%s\n", comment.Text)
		}
	} else {
		w.Printf("\n")
	}

	if c.HasOut() {
		varY = "(*" + varY + ")"
	}
	c.assigner.writeAssignCode(w, varX, varY, varErr)

	w.Printf("return\n")
	w.Printf("}\n")
}
