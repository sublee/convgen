// Package convgenerrors provides an error wrapper used at runtime in the code
// generated by Convgen. It wraps converter errors with conversion context
// prefixes while merging nested contexts to keep messages concise.
package convgenerrors

import (
	"io"
	"strings"
)

// Wrap creates a new error that wraps err with a prefix indicating the object
// being converted. The returned error message includes the conversion context.
//
// When errors are wrapped repeatedly through nested conversions, their prefixes
// are merged into a single path to avoid redundant context. For example:
//
//	converting Session.SignedUser: converting User.Name: ...
//
// becomes:
//
//	converting Session.SignedUser.Name: ...
//
// where "User" is omitted because it is already implied by "Session.SignedUser".
func Wrap(prefix string, err error) error {
	if err == nil {
		return nil
	}
	return convgenError{prefix: prefix, err: err}
}

type convgenError struct {
	prefix string
	err    error
}

func (e convgenError) Unwrap() error { return e.err }

func (e convgenError) Error() string {
	var buf strings.Builder
	buf.WriteString("converting")
	e.write(&buf, 0)
	return buf.String()
}

func (e convgenError) write(w io.Writer, depth int) {
	if e.prefix != "" {
		if depth == 0 {
			// Full prefix with leading space
			// e.g., " Foo.Bar" for prefix="Foo.Bar"
			_, _ = io.WriteString(w, " ")
			_, _ = io.WriteString(w, e.prefix)
		} else {
			// Only the suffix after the first dot with leading dot
			// e.g., ".Bar" for prefix="Foo.Bar"
			i := strings.Index(e.prefix, ".")
			if i >= 0 {
				_, _ = io.WriteString(w, ".")
				_, _ = io.WriteString(w, e.prefix[i+1:])
			}
		}
	}

	if cgErr, ok := e.err.(convgenError); ok {
		// Fold nested convgenError to a single prefix
		cgErr.write(w, depth+1)
		return
	}

	_, _ = io.WriteString(w, ": ")
	_, _ = io.WriteString(w, e.err.Error())
}
