package assign

import (
	"go/token"

	"github.com/sublee/convgen/internal/codefmt"
	"github.com/sublee/convgen/internal/typeinfo"
)

// funcAssigner converts a type to another type with a function call.
//
//	y = fn(x)      // for errorless function
//	y, err = fn(x) // for function with error
type funcAssigner struct {
	typeinfo.Func
	x, y    Object
	errWrap *errWrapAssigner
}

func (as funcAssigner) requiresErr() bool { return as.Func.HasErr() }

// callFunc creates a [funcAssigner] that calls the given function to convert x
// to y.
func (fac *factory) callFunc(x, y Object, fn typeinfo.Func) (*funcAssigner, error) {
	if fn.HasErr() && !fac.allowsErr {
		// Function has error, but may not return it.
		err := codefmt.Errorf(fac, fac.inj, "cannot call %o to convert %s to %s: error return required",
			fn, x.DebugName(), y.DebugName())
		return nil, err
	}
	return &funcAssigner{
		Func:    fn,
		x:       x,
		y:       y,
		errWrap: fac.newErrWrap(),
	}, nil
}

// tryMatchFunc tries to call a user-defined function, defined by
// [convgen.MatchFunc] or [convgen.MatchFuncErr], to convert x to y.
func (fac *factory) tryMatchFunc(x, y Object) (*funcAssigner, error) {
	if fn, ok := fac.cfg.MatchFuncs[[2]token.Pos{x.Pos(), y.Pos()}]; ok {
		return fac.callFunc(x, y, fn)
	}
	return nil, skip
}

// tryModuleFunc tries to call a function that is registered in the module where
// the target injector is defined. The functions would be:
//
// 1. User-imported functions by convgen.ImportFunc or convgen.ImportFuncErr.
// 2. The explicit converter generated by the target injector.
// 3. Automatically generated subconverters.
func (fac *factory) tryModuleFunc(x, y Object) (*funcAssigner, error) {
	if fn, ok := fac.inj.Module.Get(x.Type(), y.Type()); ok {
		return fac.callFunc(x, y, fn)
	}
	return nil, skip
}

// writeAssignCode writes code that assigns x to y by calling the function.
func (as funcAssigner) writeAssignCode(w *codefmt.Writer, varX, varY, varErr string) {
	varTmpErr := w.Name("err")

	printFunc := func() {
		if as.Name() != "" {
			w.Printf("%o", as.Func)
		} else if as.FuncLit() != nil {
			w.Printf("%c", as.Func.FuncLit())
		}
	}

	setError := func(varTmpErr string) {
		varConvgenErrors := w.Import("github.com/sublee/convgen/pkg/convgenerrors", "convgenerrors")
		w.Printf("%s = %s.Wrap(\"%s\", %s)\n", varErr, varConvgenErrors, as.x.QualName(), varTmpErr)
		as.errWrap.writeWrapCode(w, varErr)
	}

	if as.HasOut() {
		if as.requiresErr() {
			w.Printf("if %s := ", varTmpErr)
			printFunc()
			w.Printf("(%s, &(%s)); %s != nil {\n", varX, varY, varTmpErr)
			setError(varTmpErr)
			w.Printf("}\n")
		} else {
			printFunc()
			w.Printf("(%s, &(%s))\n", varX, varY)
		}
	} else {
		if as.requiresErr() {
			w.Printf("var %s error\n", varTmpErr)
			w.Printf("%s, %s = ", varY, varTmpErr)
			printFunc()
			w.Printf("(%s)\n", varX)
			w.Printf("if %s != nil {\n", varTmpErr)
			setError(varTmpErr)
			w.Printf("}\n")
		} else {
			w.Printf("%s = ", varY)
			printFunc()
			w.Printf("(%s)\n", varX)
		}
	}
}
